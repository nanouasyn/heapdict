from typing import (
    TypeVar,
    MutableMapping,
    overload,
    Iterable,
    Iterator,
    Mapping,
)

K = TypeVar("K")
P = TypeVar("P")

class BaseHeapDict(MutableMapping[K, P]):
    @overload
    def __init__(self, *, reverse=False, **kwargs: P) -> None: ...
    @overload
    def __init__(
        self, iterable: Iterable, /, *, reverse=False, **kwargs
    ) -> None: ...
    @classmethod
    def fromkeys(cls, iterable: Iterable, value) -> BaseHeapDict[K, P]: ...

    _heap: list[tuple[K, P]]
    _keys: dict[K, int]
    _reverse: bool

    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[K]: ...
    def __repr__(self) -> str: ...
    def __getitem__(self, key: K) -> P: ...
    def __setitem__(self, key: K, priority: P) -> None: ...
    def __delitem__(self, key: K) -> None: ...
    def __or__(self, other: Mapping[K, P]) -> BaseHeapDict[K, P]: ...
    def __ror__(self, other: Mapping[K, P]) -> BaseHeapDict[K, P]: ...
    def __copy__(self) -> BaseHeapDict[K, P]: ...
    def copy(self) -> BaseHeapDict[K, P]: ...
    def clear(self) -> None: ...
    def popitem(self) -> tuple[K, P]: ...
    def peekitem(self) -> tuple[K, P]: ...
    def _sift_down(self, i: int) -> None: ...
    def _sift_up(self, i: int) -> None: ...
    def _swap(self, i: int, j: int) -> None: ...

class MinHeapDict(BaseHeapDict[K, P]):
    @classmethod
    def fromkeys(cls, iterable, value) -> MinHeapDict[K, P]: ...
    def __or__(self, other: Mapping[K, P]) -> MinHeapDict[K, P]: ...
    def __ror__(self, other: Mapping[K, P]) -> MinHeapDict[K, P]: ...
    def __copy__(self) -> MinHeapDict[K, P]: ...
    def copy(self) -> MinHeapDict[K, P]: ...

class MaxHeapDict(BaseHeapDict[K, P]):
    @classmethod
    def fromkeys(cls, iterable, value) -> MaxHeapDict[K, P]: ...
    def __or__(self, other: Mapping[K, P]) -> MaxHeapDict[K, P]: ...
    def __ror__(self, other: Mapping[K, P]) -> MaxHeapDict[K, P]: ...
    def __copy__(self) -> MaxHeapDict[K, P]: ...
    def copy(self) -> MaxHeapDict[K, P]: ...
